{
  "title": "Sign your API request",
  "content": "## Introduction\nWhen calling a TikTok Shop API, a signature must be included to properly authenticate your request. All requests that do not include a signature, or have an invalid signature, will be denied access.\nTikTok Shop APIs use **HMAC-SHA256** as the default algorithm for generating signatures.\n**HS256 (HMAC with SHA-256)** is a symmetric algorithm, meaning there is only one private key that is shared between the two parties. Since the same key is used to both generate and validate the signature, care must be taken to ensure that the key is not compromised.\nWhen TikTok Shop receives an authenticated request, it recreates the signature using the authentication information contained in the request. If the signatures match, the service processes the request. Otherwise, it rejects the request.\n\n<span style=\"background-color: rgb(255, 235, 235)\">‚ùó </span><span style=\"background-color: rgb(255, 235, 235)\"><strong>Important</strong></span><span style=\"background-color: rgb(255, 235, 235)\">: TikTok Shop APIs use your </span><span style=\"background-color: rgb(255, 235, 235)\"><strong>app secret</strong></span><span style=\"background-color: rgb(255, 235, 235)\"> as the private key for authentication. You can obtain your </span><span style=\"background-color: rgb(255, 235, 235)\"><strong>app secret</strong></span><span style=\"background-color: rgb(255, 235, 235)\"> from your app details page in Partner Center.</span>\n\n![Image](https://p16-arcosite-va.ibyteimg.com/tos-maliva-i-10qhjjqwgv-us/c720f67189004b1bafa17b9a376e372b~tplv-10qhjjqwgv-image.image)\n## Code Samples\nYou can find the code samples in GoLang, Java, and Node.js below. With the code samples, you do not need to dig deep into the algorithm. If you need code samples in other languages, please highlight the sentence and provide feedback for us.\n### Signature algorithm (Go)\n```Go\nimport (  \n    \"crypto/hmac\"  \n    \"crypto/sha256\"  \n    \"encoding/hex\"  \n    \"io\"  \n    \"net/http\"  \n    \"sort\"  \n)  \n  \n// secret: App secret  \nfunc CalSign(req *http.Request, secret string) string {  \n    queries := req.URL.Query()  \n  \n    // extract all query parameters excluding sign and access_token  \n    keys := make([]string, len(queries))  \n    idx := 0  \n    for k := range queries {  \n        // params except 'sign' & 'access_token'  \n        if k != \"sign\" && k != \"access_token\" {  \n            keys[idx] = k  \n            idx++  \n        }  \n    }  \n      \n    // reorder the parameters' key in alphabetical order  \n    sort.Slice(keys, func(i, j int) bool {  \n        return keys[i] < keys[j]  \n    })  \n  \n    // Concatenate all the parameters in the format of {key}{value}  \n    input := \"\"  \n    for _, key := range keys {  \n        input = input + key + queries.Get(key)  \n    }  \n  \n    // append the request path  \n    input = req.URL.Path + input  \n  \n    // if the request header Content-type is not multipart/form-data, append body to the end  \n    mediaType, _, _ := mime.ParseMediaType(req.Header.Get(\"Content-type\"))  \n    if mediaType != \"multipart/form-data\" {  \n        body, _ := io.ReadAll(req.Body)  \n        input = input + string(body)  \n          \n        req.Body.Close()  \n        // reset body after reading from the original  \n        req.Body = io.NopCloser(bytes.NewReader(body))  \n    }  \n  \n    // wrap the string generated in step 5 with the App secret  \n    input = secret + input + secret  \n  \n    return generateSHA256(input, secret)  \n}  \n  \nfunc generateSHA256(input, secret string) string {  \n    // encode the digest byte stream in hexadecimal and use sha256 to generate sign with salt(secret)  \n    h := hmac.New(sha256.New, []byte(secret))  \n  \n    if _, err := h.Write([]byte(input)); err != nil {  \n        // TODO error log  \n        return \"\"  \n    }  \n  \n    return hex.EncodeToString(h.Sum(nil))  \n}\n```\n\n### Signature algorithm (Java)\n```Java\npackage org.example;\n\nimport okhttp3.HttpUrl;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public String generateSignature(Request request, String secret) {\n    HttpUrl httpUrl = request.url();\n    List<String> parameterNameList = new ArrayList<>(httpUrl.queryParameterNames());\n\n    // extract all query parameters excluding sign and access_token\n    parameterNameList.removeIf(param -> \"sign\".equals(param) || \"access_token\".equals(param));\n\n    // reorder the parameters' key in alphabetical order\n    Collections.sort(parameterNameList);\n\n    // append the request path\n    StringBuilder parameterStr = new StringBuilder(httpUrl.encodedPath());\n    for (String parameterName : parameterNameList) {\n        // Concatenate all the parameters in the format of {key}{value}\n        parameterStr.append(parameterName).append(httpUrl.queryParameter(parameterName));\n    }\n\n    // if the request header Content-type is not multipart/form-data, append body to the end\n    String contentType = request.header(\"Content-Type\");\n    if (!\"multipart/form-data\".equalsIgnoreCase(contentType)) {\n        try {\n            RequestBody requestBody = request.body();\n            if (requestBody != null) {\n                Buffer bodyBuffer = new Buffer();\n                requestBody.writeTo(bodyBuffer);\n                byte[] bodyBytes = bodyBuffer.readByteArray();\n                parameterStr.append(new String(bodyBytes, StandardCharsets.UTF_8));\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"failed to generate signature params\", e);\n        }\n    }\n\n    // wrap the string generated in step 5 with the App secret\n    String signatureParams = secret + parameterStr + secret;\n\n    // encode wrapped string using HMAC-SHA256\n    return generateSHA256(signatureParams, secret);\n}\n\n/**\n * generate signature by SHA256\n * @param signatureParams signature params\n * @return signature\n */\npublic String generateSHA256(String signatureParams, String secret) {\n    try {\n        // Get an HmacSHA256 Mac instance and initialize with the secret key\n        Mac sha256HMAC = Mac.getInstance(\"HmacSHA256\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), \"HmacSHA256\");\n        sha256HMAC.init(secretKeySpec);\n\n        // Update with input data\n        sha256HMAC.update(signatureParams.getBytes(StandardCharsets.UTF_8));\n\n        // Compute the HMAC and get the result\n        byte[] hashBytes = sha256HMAC.doFinal();\n\n        // Convert to hex string\n        StringBuilder sb = new StringBuilder();\n        for (byte hashByte : hashBytes) {\n            sb.append(String.format(\"%02x\", hashByte & 0xff));\n        }\n\n        return sb.toString();\n    } catch (Exception e) {\n        throw new RuntimeException(\"failed to generate signature result\", e);\n    }\n}\n}\n```\n\n### Signature algorithm (Node.js)\n```TypeScript\nimport crypto from \"crypto\";\nimport localVarRequest from \"request\";\nconst excludeKeys = [\"access_token\", \"sign\"] as const;\nexport const generateSign = (\n  requestOption: localVarRequest.Options,\n  app_secret: string\n) => {\n  let signString = \"\";\n  // step1: Extract all query parameters excluding sign and access_token. Reorder the parameter keys in alphabetical order:\n  const params = requestOption.qs || {};\n  const sortedParams = Object.keys(params)\n    .filter((key) => !excludeKeys.includes(key as any))\n    .sort()\n    .map((key) => ({ key, value: params[key] }));\n  //step2: Concatenate all the parameters in the format {key}{value}:\n  const paramString = sortedParams\n    .map(({ key, value }) => `${key}${value}`)\n    .join(\"\");\n\n  signString += paramString;\n\n  //step3: Append the string from Step 2 to the API request path:\n// @ts-ignore\n  const pathname = new URL(requestOption!.uri!||'').pathname;\n\n  signString = `${pathname}${paramString}`;\n\n  //step4: If the request header content-type is not multipart/form-data, append the API request body to the string from Step 3:\n  if (\n    requestOption.headers?.[\"content-type\"] !== \"multipart/form-data\" &&\n    requestOption.body &&\n    Object.keys(requestOption.body).length\n  ) {\n    const body = JSON.stringify(requestOption.body);\n    signString += body;\n  }\n\n  //step5: Wrap the string generated in Step 4 with the app_secret:\n  signString = `${app_secret}${signString}${app_secret}`;\n\n  //step6: Encode your wrapped string using HMAC-SHA256:\n  const hmac = crypto.createHmac(\"sha256\", app_secret);\n  hmac.update(signString);\n  const sign = hmac.digest(\"hex\");\n\n  return sign;\n};\n```\n\n### Signature algorithm (Python)\n```Python\nimport hmac\nimport hashlib\nfrom urllib.parse import urlparse\nimport json\n\ndef generate_sign(request_option, app_secret):\n    \"\"\"\n    Generate HMAC-SHA256 signature\n    :param request_option: Request options dictionary containing qs (query params), uri (path), headers, body etc.\n    :param app_secret: Secret key for signing\n    :return: Hexadecimal signature string\n    \"\"\"\n    # Step 1: Extract and filter query parameters, exclude \"access_token\" and \"sign\", sort alphabetically\n    params = request_option.get('qs', {})\n    exclude_keys = [\"access_token\", \"sign\"]\n    sorted_params = [\n        {\"key\": key, \"value\": params[key]}\n        for key in sorted(params.keys())\n        if key not in exclude_keys\n    ]\n\n    # Step 2: Concatenate parameters in {key}{value} format\n    param_string = ''.join([f\"{item['key']}{item['value']}\" for item in sorted_params])\n    sign_string = param_string\n\n    # Step 3: Append API request path to the signature string\n    uri = request_option.get('uri', '')\n    pathname = urlparse(uri).path if uri else ''\n    sign_string = f\"{pathname}{param_string}\"\n\n    # Step 4: If not multipart/form-data and request body exists, append JSON-serialized body\n    content_type = request_option.get('headers', {}).get('content-type', '')\n    body = request_option.get('body', {})\n    if content_type != 'multipart/form-data' and body:\n        body_str = json.dumps(body)  # JSON serialization ensures consistency\n        sign_string += body_str\n\n    # Step 5: Wrap signature string with app_secret\n    wrapped_string = f\"{app_secret}{sign_string}{app_secret}\"\n\n    # Step 6: Encode using HMAC-SHA256 and generate hexadecimal signature\n    hmac_obj = hmac.new(\n        app_secret.encode('utf-8'),\n        wrapped_string.encode('utf-8'),\n        hashlib.sha256\n    )\n    sign = hmac_obj.hexdigest()\n    return sign\n```\n\n## Step-by-step breakdown\n<div style=\"text-align: center\"><img src=\"https://p16-arcosite-va.ibyteimg.com/tos-maliva-i-10qhjjqwgv-us/81bed8cd51fe4913bab0c5d9979e2de0~tplv-10qhjjqwgv-image.image\" width=\"525px\" /></div>\n\nThe following is a step-by-step breakdown of how the signature algorithm works:\n\n<span style=\"background-color: rgb(255, 245, 235)\">üìå </span><span style=\"background-color: rgb(255, 245, 235)\"><strong>Note</strong></span><span style=\"background-color: rgb(255, 245, 235)\">: Feel free to skip straight to the </span><span style=\"background-color: rgb(255, 245, 235)\"><strong>signature algorithm</strong></span><span style=\"background-color: rgb(255, 245, 235)\"> sections if you do not need a step-by-step breakdown. We've provided sample code in </span>[Go](#Signature%20algorithm%20(Go))<span style=\"background-color: rgb(255, 245, 235)\">, </span>[Java](#Signature%20algorithm%20(Java))<span style=\"background-color: rgb(255, 245, 235)\">, and </span>[Node.js](#Signature%20algorithm%20(Node.js))\n\n\n1. As an example, let's assume you'd like to call the [Get Authorized Shops](get-authorized-shops) endpoint and your `app_secret` is **e59af819cc**:\n\n```HTTP\ncurl -X GET \\\n 'https://open-api.tiktokglobalshop.com/authorization/202309/shops?app_key=29a39d&sign=bc721f0e0182914e3487b81df204de37a352fc3aa96947efda6dc1e5dd0d5290&timestamp=1623812664' \\\n-H 'x-tts-access-token: TTP_pwSm2AAAAABmmtFz1xlyKMnwg74T2GJ5s0uQbS8jPjb_GkdFVCxPqzQXSyuyfXdQa0AqyDsea2tYFNVf4XeqgZHFfPyv0Vs659QqyLYfsGzanZ5XZAin3_ZkcIxxS0_In6u6XDeU96k' \\\n-H 'content-type: application/json'\n```\n\n\n\n2. Extract all query parameters excluding `sign` and `access_token`. Reorder the parameter keys in alphabetical order:\n\n```Go\nkeys := make([]string, len(queries))    \nidx := 0    \nfor k := range queries {    \n    // params except 'sign' & 'access_token'   \n    if k != \"sign\" && k != \"access_token\" {    \n       keys[idx] = k    \n       idx++    \n    }    \n}    \nsort.Slice(keys, func(i, j int) bool {    \n    return keys[i] < keys[j]    \n})\n```\n\nThe resulting reordered query keys is:\n```plaintext\nkeys = []string{    \n    \"app_key\",       \n    \"timestamp\"    \n}\n```\n\n\n<span style=\"background-color: rgb(255, 245, 235)\">üìå </span><span style=\"background-color: rgb(255, 245, 235)\"><strong>Note</strong></span><span style=\"background-color: rgb(255, 245, 235)\">: Some API endpoints will require the </span><span style=\"background-color: rgb(255, 245, 235)\"><strong>shop_cipher</strong></span><span style=\"background-color: rgb(255, 245, 235)\"> query parameter, which would then be included in the reordered query keys. Please call </span>[Get Authorized Shops](https://partner.tiktokshop.com/docv2/page/get-authorized-shops)<span style=\"background-color: rgb(255, 245, 235)\"> to obtain a shop's corresponding </span><span style=\"background-color: rgb(255, 245, 235)\"><strong>shop_cipher</strong></span><span style=\"background-color: rgb(255, 245, 235)\">.</span>\n\n\n3. Concatenate all the parameters in the format `{key}{value}`:\n\n```Go\n// Concatenate all the parameters in the format of {key}{value}  \ninput := \"\"    \nfor _, key := range keys {      \n   input = input + key + queries[key]      \n}\n```\n\nThe resulting string becomes:\n```plaintext\napp_key29a39dtimestamp1623812664\n```\n\n\n\n4. Append the string from Step 3 to the API request path. The path for [Get Authorized Shops](get-authorized-shops) is `/authorization/202309/shops`:\n\n```plaintext\ninput = path + input\n```\n\nThe resulting string becomes:\n```plaintext\n/authorization/202309/shopsapp_key29a39dtimestamp1623812664\n```\n\n\n<span style=\"background-color: rgb(255, 245, 235)\">üìå </span><span style=\"background-color: rgb(255, 245, 235)\"><strong>Note</strong></span><span style=\"background-color: rgb(255, 245, 235)\">: If the request header content-type is not multipart/form-data, append the API request body to the string as well.</span>\n```plaintext\ninput = input + body\n```\n\n<span style=\"background-color: rgb(255, 245, 235)\">For example, the </span>[Update Shop Webhook](https://partner.tiktokshop.com/docv2/page/update-shop-webhook)<span style=\"background-color: rgb(255, 245, 235)\"> endpoint includes the address and event_type parameters in the API request body (as well as the shop_cipher parameter in the query parameters). This would result in the following:</span>\n```plaintext\n/event/202309/webhooksapp_key68xu9ks5p4i8shop_cipherROW_xkMbgAAAeVAQra0eZWebFQq5aIKtimestamp1696909648{    \"address\":\"https://partner.tiktokshop.com\",    \"event_type\": \"PACKAGE_UPDATE\"}\n```\n\n\n\n5. Wrap the string generated in Step 4 with your `app_secret`:\n\n```plaintext\ninput = app_secret + input + app_secret\n```\n\nThe final string becomes:\n```plaintext\ne59af819cc/authorization/202309/shopsapp_key29a39dtimestamp1623812664e59af819cc\n```\n\n\n\n6. Encode your wrapped string using **HMAC-SHA256**:\n\n```Go\nimport (      \n   \"crypto/hmac\"      \n   \"crypto/sha256\"      \n   \"encoding/hex\"      \n   \"sort\"      \n)      \n/**      \n** input: string we created in step 2   \n** secret: App secret      \n**/      \nfunc generateSHA256(input, secret string) string{      \n   // encode the digest byte stream in hexadecimal and use sha256 to generate sign with salt(secret)      \n   h := hmac.New(sha256.New, []byte(secret))      \n  \n   if _, err := h.Write([]byte(input)); err != nil{      \n      // TODO error log   \n      return \"\"      \n   }      \n      \n   return hex.EncodeToString(h.Sum(nil))      \n}\n```\n\nThe resulting sign is:\n```plaintext\nb596b73e0cc6de07ac26f036364178ab16b0a907af13d43f0a0cd2345f582dc8\n```\n\n## Common mistakes\nWhat is the most common reason for encountering the \"signature is invalid\" error during an API call?\n\n* Frequently, this error occurs when developers use incorrect app keys and secrets to generate the signature. It's essential to verify that the app key and secret match precisely.\n* Ensure `sign` and `access_token` are **not** included in the reordered query keys (Step 2).\n* Always ensure that you are using the **HMAC-SHA256** signature method (different from regular SHA-256).\n* Ensure that the timestamp is within 5 minutes of the current time when the platform receives the request. The timestamp must be represented as a 10-digit Unix timestamp.\n\n\n",
  "update_time": "1751449658",
  "view_count": 0,
  "prev_document_id": "678e3a4278f4c20311b8b57e",
  "prev_document_path": "common-parameters",
  "next_document_id": "678e3a45786253031531b942",
  "next_document_path": "common-errors",
  "is_api_doc": false,
  "document_id": "678e3a3d4ddec3030b238faf",
  "doc_type": 2,
  "keywords": [
    {
      "keyword": "",
      "font_color": "#141414",
      "background_color": "#E6E6E6"
    }
  ]
}